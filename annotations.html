<html>
<head>
	<title>com4j annotation guide</title>
	<meta http-equiv="Content-type" value="text/html; charset=iso-8859-1" />
	<style>
		pre.cmd {
			background-color: black;
			color: white;
			font-weight: bold;
			margin-left: 2em;
			padding: 0.5em;
		}
		
		pre.code {
			border: black solid 1px;
			background-color: rgb(240,240,255);
			color: navy;
			font-weight: bold;
			margin-left: 2em;
			padding: 0.5em;
		}
		pre.code .annotation {
			color: gray;
		}
		
		pre.com {
			border: black solid 1px;
			background-color: rgb(240,255,240);
			color: darkgreen;
			font-weight: bold;
			margin-left: 2em;
			padding: 0.5em;
		}
	</style>
</head>
<body>
<h1>com4j Annotation Guide</h1>

	<p>
		This document explains the details of how the runtime bridges a Java method invocation into a COM method invocation, and how one can use annotations to control this process.
	
	<p>
		In the most general form, a Java method can be annotated as follows:

<pre class=code>
@IID(<i>iid</i>)
public interface INTERFACE {
  @VTID(<i>vtid</i>)
  @ReturnValue(index=<i>rindex</i>,inout=<i>rio</i>,type=<i>rt</i>)
  T foo(
    @MarshalAs(<i>t1</i>) T1 param1,
    @MarshalAs(<i>t2</i>) T2 param2,
    ... );
}
</pre>
<h4>IID</h4>
	<p>
		The <i>iid</i> parameter of the surrounding interface designates the IID of the COM interface. The method invocation is done against this interface of a COM object.
	
<h4>VTID</h4>
	<p>
		The mandatory <i>vtid</i> parameter describes the index of the method in the given interface. The com4j runtime never uses the method name information to decide which COM method to invoke.
		
		You can deteminer the virtual-table index by counting methods defined on that interface. For example, <tt>IUnknown</tt> has 3 methods, so <tt>@VTID(3)</tt> would designate the first method on an interface derived from <tt>IUnknown</tt>. <tt>IDispatch</tt> defines 4 additional methods, so the first method on an interface derived from <tt>IDispatch</tt> would have <tt>@VITD(7)</tt>.
	<p>
		Using the wrong VTID often causes the JVM to crash, because you end up calling a wrong method (or non-existent method) with a wrong set of parameters. So be careful when you manually tweak this.

<h4>rindex</h4>
	<p>
		In COM, a return value is usually passed as a parameter by reference. Therefore, when a Java method has a return value, com4j bridges it as a parameter.
		
		The optional <i>rindex</i> specifies where this parameter is passed among the real parameters. For example, the following Java method:
		
<pre class=code>
@ReturnValue(index=0) Tr foo( T1 t1, T2 t2 )
</pre>
	<p>
		would be bridged to the following COM method invocation:
<pre class=com>
HRESULT Foo( [out,retval] Tr* r, T1 t1, T2 t2 );
</pre>
	<p>
		Similarly, the following Java method:
		
<pre class=code>
@ReturnValue(index=1) Tr foo( T1 t1, T2 t2 )
</pre>
	<p>
		would be bridged to the following COM method invocation:
<pre class=com>
HRESULT Foo( T1 t1, [out,retval] Tr* r, T2 t2 );
</pre>
	<p>
		When <i>rindex</i> is omitted, it means that the return value is passed after the last parameter, which is what most COM methods do.

<h4>rio</h4>
	<p>
		Although rare, a COM method parameter can have <tt>[in,out,retval]</tt> semantics, which means it takes a value from the caller, modifies it, and returns it as the return value of the method.
	<p>
		Specifying <tt>true</tt> for <i>rio</i> would achieve this semantics. With this switch turned on, instead of inserting a return value among the parameters, the com4j runtime overloads the designated parameter both as a parameter and a return value. Thus the following Java method:
		
<pre class=code>
@ReturnValue(index=1,inout=true) T2 foo( T1 t1, T2 t2 )
</pre>
	<p>
		would be bridged to the following COM method invocation:
<pre class=com>
HRESULT Foo( T1 t1, [int,out,retval] T2* t2 );
</pre>


<h4>rt</h4>
	<p>
		The optional <tt>rt</tt> parameter specifies the native return type for this method and the semantics of how the return value is mapped to Java. When omitted, <a href="/nonav/javadoc/com4j/NativeType.html#Default">a pre-defined table</a> is used to decide which native type to use from the Java return type.
	
	<p>
		For possible values, their semantics, and allowed Java types, see the <a href="/nonav/javadoc/com4j/NativeType.html">javadoc of <tt>NativeType</tt></a>.


<h4>t1,t2,...</h4>
	<p>
		Parameters can be optionally annotated by the <tt>MarshalAs</tt> attribute to control how a Java parameter is bound to a parameter of a native type. When omitted, the same <a href="/nonav/javadoc/com4j/NativeType.html#Default">pre-defined table</a> is used to decide which native type to use.
	
	<p>
		<tt>NativeType</tt> specified for the return type and <tt>NativeType</tt> specified for parameters sometimes have slightly different semantics. See the <a href="/nonav/javadoc/com4j/NativeType.html">javadoc</a> for details.




<h3>COM Error and Exception</h3>
	<p>
		Consider the following COM method:
<pre class=com>
[helpstring("get the child object.")]
HRESULT GetItem( [int] int index, [out,retval] IFoo** ppItem );
</pre>
	<p>
		A COM method not just returns a "conceptual" return value (<tt>IFoo*</tt>) but also returns a HRESULT. <tt>tlbimp</tt> always hide HRESULT from Java, thus the above method is bound to:
<pre class=code>
IFoo GetItem( int index );
</pre>
	<p>
		When the COM method invocation returns a failure HRESULT, the com4j runtime throws unchecked ComException.
	<p>
		Sometimes a COM method actually uses this HRESULT to return a meaningful value. For example,
<pre class=com>
[helpstring("count the items and returns it, or return a failure code.")]
HRESULT CountItems();
</pre>
	<p>
		If you want to access the HRESULT return value, use <tt>NativeType.HRESULT</tt> as follows, which returns the HRESULT value as a Java int:
<pre class=code>
@ReturnValue(type=NativeType.HRESULT)
int countItems();
</pre>
</body>
</html>
